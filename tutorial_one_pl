Programming Language - Tutorial OpenA

1st Chapter:Preliminaries

Questions Oversview:


1. Why is it useful for a programmer to have some background in language
design, even though he or she may never actually design a programming
language?

2. How can knowledge of programming language characteristics benefit the

whole computing community?

3. What programming language has dominated scientific computing over

the past 50 years?

4. What programming language has dominated business applications over

the past 50 years?

5. What programming language has dominated artificial intelligence over

the past 50 years?

6. In what language is most of UNIX written?
7. What is the disadvantage of having too many features in a language?
8. How can user-defined operator overloading harm the readability of a

program?

9. What is one example of a lack of orthogonality in the design of C?
10. What language used orthogonality as a primary design criterion?
11. What primitive control statement is used to build more complicated

control statements in languages that lack them?

12. What construct of a programming language provides process

abstraction?

13. What does it mean for a program to be reliable?
14. Why is type checking the parameters of a subprogram important?
15. What is aliasing?


16. What is exception handling?
17. Why is readability important to writability?
18. How is the cost of compilers for a given language related to the design of

that language?

19. What have been the strongest influences on programming language

design over the past 50 years?

20. What is the name of the category of programming languages whose
structure is dictated by the von Neumann computer architecture?
21. What two programming language deficiencies were discovered as a
result of the research in software development in the 1970s?

22. What are the three fundamental features of an object-oriented program-
ming language?

23. What language was the first to support the three fundamental features of

object-oriented programming?

24. What is an example of two language design criteria that are in direct

conflict with each other?

25. What are the three general methods of implementing a programming

language?

26. Which produces faster program execution, a compiler or a pure

interpreter?

27. What role does the symbol table play in a compiler?
28. What does a linker do?
29. Why is the von Neumann bottleneck important?
30. What are the advantages in implementing a language with a pure

interpreter?



Problem Set:

1. Do you believe our capacity for abstract thought is influenced by our

language skills? Support your opinion.

2. What are some features of specific programming languages you know

whose rationales are a mystery to you?

3. What arguments can you make for the idea of a single language for all

programming domains?

4. What arguments can you make against the idea of a single language for

all programming domains?

5. Name and explain another criterion by which languages can be judged

(in addition to those discussed in this chapter).



6. What common programming language statement, in your opinion, is

most detrimental to readability?

7. Java uses a right brace to mark the end of all compound statements.

What are the arguments for and against this design?

8. Many languages distinguish between uppercase and lowercase letters in
user-defined names. What are the pros and cons of this design decision?
9. Explain the different aspects of the cost of a programming language.
10. What are the arguments for writing efficient programs even though

hardware is relatively inexpensive?

11. Describe some design trade-offs between efficiency and safety in some

language you know.

12. In your opinion, what major features would a perfect programming lan-
guage include?

13. Was the first high-level programming language you learned imple-
mented with a pure interpreter, a hybrid implementation system, or a

compiler? (You may have to research this.)

14. Describe the advantages and disadvantages of some programming envi-
ronment you have used.

15. How do type declaration statements for simple variables affect the read-
ability of a language, considering that some languages do not require

them?

16. Write an evaluation of some programming language you know, using the

criteria described in this chapter.

17. Some programming languages—for example, Pascal—have used the

semicolon to separate statements, while Java uses it to terminate state-
ments. Which of these, in your opinion, is most natural and least likely

to result in syntax errors? Support your answer.

18. Many contemporary languages allow two kinds of comments: one in
which delimiters are used on both ends (multiple-line comments), and

one in which a delimiter marks only the beginning of the comment (one-
line comments). Discuss the advantages and disadvantages of each of

these with respect to our criteria.



2nd Chapter (Evolution of the Major Programming Languages)

Review Question:


1. In what year was Plankalkül designed? In what year was that design

published?

2. What two common data structures were included in Plankalkül?
3. How were the pseudocodes of the early 1950s implemented?
4. Speedcoding was invented to overcome two significant shortcomings of

the computer hardware of the early 1950s. What were they?
5. Why was the slowness of interpretation of programs acceptable in the

early 1950s?

6. What hardware capability that first appeared in the IBM 704 computer
strongly affected the evolution of programming languages? Explain why.

7. In what year was the Fortran design project begun?
8. What was the primary application area of computers at the time Fortran

was designed?

9. What was the source of all of the control flow statements of Fortran I?
10. What was the most significant feature added to Fortran I to get Fortran

II?

11. What control flow statements were added to Fortran IV to get Fortran

77?

12. Which version of Fortran was the first to have any sort of dynamic

variables?

13. Which version of Fortran was the first to have character string handling?
14. Why were linguists interested in artificial intelligence in the late 1950s?
15. Where was LISP developed? By whom?
16. In what way are Scheme and Common LISP opposites of each other?
17. What dialect of LISP is used for introductory programming courses at

some universities?

18. What two professional organizations together designed ALGOL 60?
19. In what version of ALGOL did block structure appear?
20. What missing language element of ALGOL 60 damaged its chances for

widespread use?

21. What language was designed to describe the syntax of ALGOL 60?
22. On what language was COBOL based?
23. In what year did the COBOL design process begin?
24. What data structure that appeared in COBOL originated with

Plankalkül?

25. What organization was most responsible for the early success of

COBOL (in terms of extent of use)?


26. What user group was the target of the first version of BASIC?
27. Why was BASIC an important language in the early 1980s?
28. PL/I was designed to replace what two languages?
29. For what new line of computers was PL/I designed?

30. What features of SIMULA 67 are now important parts of some object-
oriented languages?

31. What innovation of data structuring was introduced in ALGOL 68 but is

often credited to Pascal?

32. What design criterion was used extensively in ALGOL 68?
33. What language introduced the case statement?
34. What operators in C were modeled on similar operators in ALGOL 68?
35. What are two characteristics of C that make it less safe than Pascal?
36. What is a nonprocedural language?
37. What are the two kinds of statements that populate a Prolog database?
38. What is the primary application area for which Ada was designed?
39. What are the concurrent program units of Ada called?
40. What Ada construct provides support for abstract data types?
41. What populates the Smalltalk world?
42. What three concepts are the basis for object-oriented programming?
43. Why does C++ include the features of C that are known to be unsafe?
44. From what language does Objective-C borrow its syntax for method

calls?

45. What programming paradigm that nearly all recently designed languages

support is not supported by Go?

46. What is the primary application for Objective-C?
47. What language designer worked on both C and Go?
48. What do the Ada and COBOL languages have in common?
49. What was the first application for Java?
50. What characteristic of Java is most evident in JavaScript?
51. How does the typing system of PHP and JavaScript differ from that of

Java?

52. What array structure is included in C# but not in C, C++, or Java?
53. What two languages was the original version of Perl meant to replace?
54. For what application area is JavaScript most widely used?
55. What is the relationship between JavaScript and PHP, in terms of their

use?

56. PHP’s primary data structure is a combination of what two data struc-
tures from other languages?

57. What data structure does Python use in place of arrays?
58. What characteristic does Ruby share with Smalltalk?
59. What characteristic of Ruby’s arithmetic operators makes them unique

among those of other languages?
60. What data structures are built into Lua?
61. Is Lua normally compiled, purely interpreted, or impurely interpreted?
62. What feature of Delphi’s classes is included in C#?
63. What deficiency of the switch statement of C is addressed with the

changes made by C# to that statement?

64. What is the primary platform on which C# is used?
65. What are the inputs to an XSLT processor?
66. What is the output of an XSLT processor?
67. What element of the JSTL is related to a subprogram?
68. To what is a JSP document converted by a JSP processor?
69. Where are servlets executed?

Problem Sets:

1. What features of Plankalkül do you think would have had the greatest
influence on Fortran 0 if the Fortran designers had been familiar with
Plankalkül?

2. Determine the capabilities of Backus’s 701 Speedcoding system, and
compare them with those of a contemporary programmable hand
calculator.

3. Write a short history of the A-0, A-1, and A-2 systems designed by

Grace Hopper and her associates.

4. As a research project, compare the facilities of Fortran 0 with those of

the Laning and Zierler system.

5. Which of the three original goals of the ALGOL design committee, in

your opinion, was most difficult to achieve at that time?

6. Make an educated guess as to the most common syntax error in LISP

programs.

7. LISP began as a pure functional language but gradually acquired more

and more imperative features. Why?

8. Describe in detail the three most important reasons, in your opinion,
why ALGOL 60 did not become a very widely used language.
9. Why, in your opinion, did COBOL allow long identifiers when Fortran

and ALGOL did not?

10. Outline the major motivation of IBM in developing PL/I.
11. Was IBM’s assumption, on which it based its decision to develop PL/I,
correct, given the history of computers and language developments since
1964?

12. Describe, in your own words, the concept of orthogonality in program-
ming language design.

13. What is the primary reason why PL/I became more widely used than

ALGOL 68?

14. What are the arguments both for and against the idea of a typeless

language?

15. Are there any logic programming languages other than Prolog?

16. What is your opinion of the argument that languages that are too com-
plex are too dangerous to use, and we should therefore keep all languages

small and simple?

17. Do you think language design by committee is a good idea? Support

your opinion.

18. Languages continually evolve. What sort of restrictions do you think
are appropriate for changes in programming languages? Compare your
answers with the evolution of Fortran.

19. Build a table identifying all of the major language developments,
together with when they occurred, in what language they first appeared,
and the identities of the developers.

20. There have been some public interchanges between Microsoft and
Sun concerning the design of Microsoft’s J++ and C# and Sun’s Java.
Read some of these documents, which are available on their respective
Web sites, and write an analysis of the disagreements concerning the
delegates.

21. In recent years data structures have evolved within scripting languages
to replace traditional arrays. Explain the chronological sequence of these
developments.

22. Explain two reasons why pure interpretation is an acceptable implemen-
tation method for several recent scripting languages.

23. Perl 6, when it arrives, will likely be a significantly enlarged language.
Make an educated guess as to whether a language like Lua will also grow
continuously over its lifetime. Support your answer.

24. Why, in your opinion, do new scripting languages appear more fre-
quently than new compiled languages?

25. Give a brief general description of a markup/programming hybrid

language.



Chapter 3 (Describing Syntax and Semantics)


Question Overview:

1. Define syntax and semantics.
2. Who are language descriptions for?
3. Describe the operation of a general language generator.
4. Describe the operation of a general language recognizer.
5. What is the difference between a sentence and a sentential form?
6. Define a left-recursive grammar rule.
7. What three extensions are common to most EBNFs?
8. Distinguish between static and dynamic semantics.
9. What purpose do predicates serve in an attribute grammar?
10. What is the difference between a synthesized and an inherited attribute?
11. How is the order of evaluation of attributes determined for the trees of a

given attribute grammar?

12. What is the primary use of attribute grammars?
13. Explain the primary uses of a methodology and notation for describing

the semantics of programming languages.

14. Why can machine languages not be used to define statements in opera-
tional semantics?

15. Describe the two levels of uses of operational semantics.
16. In denotational semantics, what are the syntactic and semantic domains?
17. What is stored in the state of a program for denotational semantics?
18. Which semantics approach is most widely known?
19. What two things must be defined for each language entity in order to

construct a denotational description of the language?
20. Which part of an inference rule is the antecedent?
21. What is a predicate transformer function?
22. What does partial correctness mean for a loop construct?
23. On what branch of mathematics is axiomatic semantics based?
24. On what branch of mathematics is denotational semantics based?

Problem Set 163

25. What is the problem with using a software pure interpreter for opera-
tional semantics?

26. Explain what the preconditions and postconditions of a given statement

mean in axiomatic semantics.

27. Describe the approach of using axiomatic semantics to prove the correct-
ness of a given program.

28. Describe the basic concept of denotational semantics.
29. In what fundamental way do operational semantics and denotational

semantics differ?

PROBLEM SET:


1. The two mathematical models of language description are generation

and recognition. Describe how each can define the syntax of a program-
ming language.

2. Write EBNF descriptions for the following:
a. A Java class definition header statement
b. A Java method call statement
c. A C switch statement
d. A C union definition
e. C float literals

3. Rewrite the BNF of Example 3.4 to give + precedence over * and force +

to be right associative.

4. Rewrite the BNF of Example 3.4 to add the ++ and -- unary operators

of Java.

5. Write a BNF description of the Boolean expressions of Java, including
the three operators &&, ||, and ! and the relational expressions.
6. Using the grammar in Example 3.2, show a parse tree and a leftmost

derivation for each of the following statements:
a. A = A * (B + (C * A))
b. B = C * (A * C + B)
c. A = A * (B + (C))

7. Using the grammar in Example 3.4, show a parse tree and a leftmost

derivation for each of the following statements:
a. A = ( A + B ) * C
b. A = B + C + A
c. A = A * (B + C)
d. A = B * (C * (A + B))


8. Prove that the following grammar is ambiguous:

<S> → <A>
<A> → <A> + <A> | <id>
<id> → a | b | c

9. Modify the grammar of Example 3.4 to add a unary minus operator that

has higher precedence than either + or *.

10. Describe, in English, the language defined by the following grammar:

<S> → <A> <B> <C>
<A> → a <A> | a
<B> → b <B> | b
<C> → c <C> | c

11. Consider the following grammar:

<S> → <A> a <B> b
<A> → <A> b | b
<B> → a <B> | a
Which of the following sentences are in the language generated by this
grammar?
a. baab
b. bbbab
c. bbaaaaa
d. bbaab

12. Consider the following grammar:
<S> → a <S> c <B> | <A> | b
<A> → c <A> | c
<B> → d | <A>
Which of the following sentences are in the language generated by this
grammar?
a. abcd
b. acccbd
c. acccbcc
d. acd
e. accc

13. Write a grammar for the language consisting of strings that have n
copies of the letter a followed by the same number of copies of the
letter b, where n > 0. For example, the strings ab, aaaabbbb, and
aaaaaaaabbbbbbbb are in the language but a, abb, ba, and aaabb are not.
14. Draw parse trees for the sentences aabb and aaaabbbb, as derived from

the grammar of Problem 13.



15. Convert the BNF of Example 3.1 to EBNF.
16. Convert the BNF of Example 3.3 to EBNF.
17. Convert the following EBNF to BNF:

S → A{bA}
A → a[b]A

18. What is the difference between an intrinsic attribute and a nonintrinsic

synthesized attribute?

19. Write an attribute grammar whose BNF basis is that of Example 3.6 in
Section 3.4.5 but whose language rules are as follows: Data types cannot
be mixed in expressions, but assignment statements need not have the
same types on both sides of the assignment operator.

20. Write an attribute grammar whose base BNF is that of Example 3.2 and
whose type rules are the same as for the assignment statement example
of Section 3.4.5.

21. Using the virtual machine instructions given in Section 3.5.1.1, give an

operational semantic definition of the following:
a. Java do-while
b. Ada for
c. C++ if-then-else
d. C for
e. C switch

22. Write a denotational semantics mapping function for the following

statements:
a. Ada for
b. Java do-while
c. Java Boolean expressions
d. Java for
e. C switch

23. Compute the weakest precondition for each of the following assignment

statements and postconditions:
a. a = 2 * (b - 1) - 1 {a > 0}
b. b = (c + 10) / 3 {b > 6}
c. a = a + 2 * b - 1 {a > 1}
d. x = 2 * y + x - 1 {x > 11}

24. Compute the weakest precondition for each of the following sequences

of assignment statements and their postconditions:
a. a = 2 * b + 1;
b = a - 3
{b < 0}

166 Chapter 3 Describing Syntax and Semantics
b. a = 3 * (2 * b + a);
b = 2 * a - 1
{b > 5}

25. Compute the weakest precondition for each of the following selection

constructs and their postconditions:
a. if (a == b)
b = 2 * a + 1
else
b = 2 * a;
{b > 1}
b. if (x < y)
x = x + 1
else
x = 3 * x
{x < 0}
c. if (x > y)
y = 2 * x + 1
else
y = 3 * x - 1;
{y > 3}

26. Explain the four criteria for proving the correctness of a logical pretest

loop construct of the form while B do S end

27. Prove that (n + 1) * c * n = 1
28. Prove the following program is correct:

{n > 0}
count = n;
sum = 0;
while count <> 0 do
sum = sum + count;
count = count - 1;
end
{sum = 1 + 2 + . . . + n}